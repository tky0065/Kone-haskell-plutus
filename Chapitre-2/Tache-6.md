## ‚úÖ HC2T6 - Comprendre Int vs Integer

### üéØ Objectif
Comprendre la diff√©rence fondamentale entre **Int** et **Integer** en Haskell - deux types d'entiers avec des caract√©ristiques tr√®s diff√©rentes en termes de **taille**, **performance** et **pr√©cision**. Apprendre quand utiliser chaque type selon le contexte.

### üìù Concepts Cl√©s
- **Int** : Entier de taille fixe (g√©n√©ralement 64 bits), plus rapide mais limit√©
- **Integer** : Entier de pr√©cision arbitraire, illimit√© mais plus lent
- **Overflow** : D√©passement de capacit√© avec Int, impossible avec Integer
- **Performance** : Int plus rapide pour les calculs, Integer plus s√ªr pour les grands nombres

### üíª Code Complet

```haskell
-- Main.hs

-- | D√©finition des variables avec types sp√©cifiques
-- Ces exemples montrent les diff√©rences de capacit√©

-- Nombre utilisant Int - limit√© par la taille de la machine
smallNumber :: Int
smallNumber = 2^62  -- Proche de la limite maximale d'Int

-- Nombre utilisant Integer - pas de limite th√©orique
bigNumber :: Integer
bigNumber = 2^127   -- Bien au-del√† des capacit√©s d'Int

-- Tr√®s grand nombre pour d√©montrer la puissance d'Integer
hugeNumber :: Integer
hugeNumber = 2^1000  -- Impossible avec Int !

-- | Constantes pour tester les limites d'Int
-- Ces valeurs sont proches des limites syst√®me
maxIntApprox :: Int
maxIntApprox = 9223372036854775807  -- 2^63 - 1 (sur syst√®me 64 bits)

minIntApprox :: Int
minIntApprox = -9223372036854775808  -- -2^63 (sur syst√®me 64 bits)

-- | Fonctions pour d√©montrer les diff√©rences de comportement

-- Calcule la factorielle avec Int (risque d'overflow)
factorialInt :: Int -> Int
factorialInt n
  | n <= 0 = 1
  | otherwise = n * factorialInt (n - 1)

-- Calcule la factorielle avec Integer (pas de risque d'overflow)
factorialInteger :: Integer -> Integer
factorialInteger n
  | n <= 0 = 1
  | otherwise = n * factorialInteger (n - 1)

-- Calcule une puissance avec Int
powerInt :: Int -> Int -> Int
powerInt base exp
  | exp == 0 = 1
  | exp > 0 = base * powerInt base (exp - 1)
  | otherwise = error "Exposant n√©gatif"

-- Calcule une puissance avec Integer
powerInteger :: Integer -> Integer -> Integer
powerInteger base exp
  | exp == 0 = 1
  | exp > 0 = base * powerInteger base (exp - 1)
  | otherwise = error "Exposant n√©gatif"

-- | Fonctions de conversion entre Int et Integer

-- Convertit Int vers Integer (toujours s√ªr)
intToInteger :: Int -> Integer
intToInteger = fromIntegral

-- Convertit Integer vers Int (peut perdre de la pr√©cision)
integerToInt :: Integer -> Int
integerToInt = fromIntegral

-- | Fonctions de test pour comparer les performances

-- Suite de Fibonacci avec Int (limit√©)
fibInt :: Int -> Int
fibInt n
  | n <= 1 = n
  | otherwise = fibInt (n-1) + fibInt (n-2)

-- Suite de Fibonacci avec Integer (illimit√©)
fibInteger :: Integer -> Integer
fibInteger n
  | n <= 1 = fromIntegral n
  | otherwise = fibInteger (n-1) + fibInteger (n-2)

-- | Fonction de test des limites
testIntLimits :: IO ()
testIntLimits = do
  putStrLn "=== COMPARAISON INT VS INTEGER ==="
  putStrLn ""
  
  -- Affichage des valeurs de base
  putStrLn "üî¢ Valeurs de test :"
  putStrLn $ "‚Ä¢ smallNumber (Int) = " ++ show smallNumber
  putStrLn $ "‚Ä¢ bigNumber (Integer) = " ++ show bigNumber
  putStrLn $ "‚Ä¢ Longueur bigNumber : " ++ show (length (show bigNumber)) ++ " chiffres"
  putStrLn ""
  
  -- D√©monstration des limites d'Int
  putStrLn "üìè Limites approximatives d'Int (syst√®me 64 bits) :"
  putStrLn $ "‚Ä¢ Maximum Int ‚âà " ++ show maxIntApprox
  putStrLn $ "‚Ä¢ Minimum Int ‚âà " ++ show minIntApprox
  putStrLn $ "‚Ä¢ Plage : environ " ++ show (fromIntegral maxIntApprox / 10^18 :: Double) ++ " √ó 10^18"
  putStrLn ""

-- | Fonction principale pour d√©montrer les diff√©rences
main :: IO ()
main = do
  testIntLimits
  
  -- =========================================================================
  -- SECTION 1: COMPARAISON DES CAPACIT√âS
  -- =========================================================================
  putStrLn "=== COMPARAISON DES CAPACIT√âS ==="
  putStrLn ""
  
  putStrLn "üöÄ Nombre √©norme avec Integer :"
  putStrLn $ "‚Ä¢ 2^1000 = " ++ take 50 (show hugeNumber) ++ "... (" ++ 
             show (length (show hugeNumber)) ++ " chiffres au total)"
  putStrLn "  ‚Üí Impossible √† repr√©senter avec Int !"
  putStrLn ""
  
  -- =========================================================================
  -- SECTION 2: TESTS DE FACTORIELLES
  -- =========================================================================
  putStrLn "=== TESTS DE FACTORIELLES ==="
  putStrLn ""
  
  putStrLn "üî¢ Factorielles avec Int (attention aux d√©bordements) :"
  let intFactorials = [1, 5, 10, 15, 20]
  mapM_ (\n -> do
    let result = factorialInt n
    putStrLn $ "‚Ä¢ " ++ show n ++ "! = " ++ show result ++ " (Int)"
    ) intFactorials
  putStrLn "  ‚ö†Ô∏è  Au-del√† de 20!, les r√©sultats peuvent d√©border"
  putStrLn ""
  
  putStrLn "üî¢ Factorielles avec Integer (pr√©cision illimit√©e) :"
  let integerFactorials = [1, 5, 10, 20, 30, 50]
  mapM_ (\n -> do
    let result = factorialInteger (fromIntegral n)
    let resultStr = show result
    if length resultStr > 50
      then putStrLn $ "‚Ä¢ " ++ show n ++ "! = " ++ take 30 resultStr ++ "... (" ++ 
                      show (length resultStr) ++ " chiffres)"
      else putStrLn $ "‚Ä¢ " ++ show n ++ "! = " ++ resultStr ++ " (Integer)"
    ) integerFactorials
  putStrLn ""
  
  -- =========================================================================
  -- SECTION 3: TESTS DE PUISSANCES
  -- =========================================================================
  putStrLn "=== TESTS DE PUISSANCES ==="
  putStrLn ""
  
  putStrLn "‚ö° Puissances avec Int (limit√©) :"
  let intPowers = [(2, 10), (2, 30), (2, 60)]
  mapM_ (\(base, exp) -> do
    let result = powerInt base exp
    putStrLn $ "‚Ä¢ " ++ show base ++ "^" ++ show exp ++ " = " ++ show result ++ " (Int)"
    ) intPowers
  putStrLn "  ‚ö†Ô∏è  2^60 et plus peuvent d√©border"
  putStrLn ""
  
  putStrLn "‚ö° Puissances avec Integer (illimit√©) :"
  let integerPowers = [(2, 10), (2, 100), (2, 200), (10, 50)]
  mapM_ (\(base, exp) -> do
    let result = powerInteger (fromIntegral base) (fromIntegral exp)
    let resultStr = show result
    if length resultStr > 40
      then putStrLn $ "‚Ä¢ " ++ show base ++ "^" ++ show exp ++ " = " ++ take 20 resultStr ++ "... (" ++ 
                      show (length resultStr) ++ " chiffres)"
      else putStrLn $ "‚Ä¢ " ++ show base ++ "^" ++ show exp ++ " = " ++ resultStr ++ " (Integer)"
    ) integerPowers
  putStrLn ""
  
  -- =========================================================================
  -- SECTION 4: CONVERSION ENTRE TYPES
  -- =========================================================================
  putStrLn "=== CONVERSIONS ENTRE INT ET INTEGER ==="
  putStrLn ""
  
  let testInt = 12345 :: Int
  let convertedToInteger = intToInteger testInt
  let convertedBackToInt = integerToInt convertedToInteger
  
  putStrLn $ "‚Ä¢ Int original : " ++ show testInt
  putStrLn $ "‚Ä¢ Converti en Integer : " ++ show convertedToInteger
  putStrLn $ "‚Ä¢ Reconverti en Int : " ++ show convertedBackToInt
  putStrLn "  ‚Üí Conversion Int ‚Üí Integer ‚Üí Int sans perte"
  putStrLn ""
  
  -- Test avec un grand Integer
  let bigInt = 999999999999999999999 :: Integer
  let truncatedInt = integerToInt bigInt
  putStrLn $ "‚Ä¢ Grand Integer : " ++ show bigInt
  putStrLn $ "‚Ä¢ Converti en Int : " ++ show truncatedInt
  putStrLn "  ‚ö†Ô∏è  Perte de pr√©cision lors de la conversion !"
  putStrLn ""
  
  -- =========================================================================
  -- SECTION 5: ANALYSE DES PERFORMANCES
  -- =========================================================================
  putStrLn "=== ANALYSE DES PERFORMANCES ==="
  putStrLn ""
  
  putStrLn "üèÉ Performance Int vs Integer :"
  putStrLn "‚Ä¢ Int : Plus rapide pour les calculs simples"
  putStrLn "‚Ä¢ Integer : Plus lent mais plus s√ªr pour les grands nombres"
  putStrLn ""
  
  -- Fibonacci avec des petits nombres
  putStrLn "üî¢ Fibonacci (petits nombres) :"
  let fibTests = [10, 15, 20]
  mapM_ (\n -> do
    let resultInt = fibInt n
    let resultInteger = fibInteger (fromIntegral n)
    putStrLn $ "‚Ä¢ fib(" ++ show n ++ ") = " ++ show resultInt ++ " (Int) = " ++ 
               show resultInteger ++ " (Integer)"
    ) fibTests
  putStrLn ""
  
  -- =========================================================================
  -- SECTION 6: RECOMMANDATIONS D'USAGE
  -- =========================================================================
  putStrLn "=== RECOMMANDATIONS D'USAGE ==="
  putStrLn ""
  putStrLn "üéØ Quand utiliser Int :"
  putStrLn "‚Ä¢ ‚úÖ Calculs simples et rapides"
  putStrLn "‚Ä¢ ‚úÖ Indices de tableaux, compteurs"
  putStrLn "‚Ä¢ ‚úÖ Valeurs garanties petites"
  putStrLn "‚Ä¢ ‚úÖ Performance critique"
  putStrLn ""
  putStrLn "üéØ Quand utiliser Integer :"
  putStrLn "‚Ä¢ ‚úÖ Calculs math√©matiques complexes"
  putStrLn "‚Ä¢ ‚úÖ Factorielles, puissances √©lev√©es"
  putStrLn "‚Ä¢ ‚úÖ Cryptographie, grands nombres"
  putStrLn "‚Ä¢ ‚úÖ Precision absolue requise"
  putStrLn ""
  putStrLn "‚öñÔ∏è  Compromis :"
  putStrLn "‚Ä¢ Int = Vitesse vs Limitation"
  putStrLn "‚Ä¢ Integer = Pr√©cision vs Performance"
  putStrLn ""
  
  putStrLn "‚úÖ Choisissez le bon type selon vos besoins !"
```

### üîç Instructions GHCi

```ghci
-- Dans GHCi, testez les diff√©rences Int vs Integer :

-- V√©rification des types
:t (42 :: Int)
-- (42 :: Int) :: Int

:t (42 :: Integer)  
-- (42 :: Integer) :: Integer

-- Test des limites
let maxInt = 9223372036854775807 :: Int
maxInt
-- 9223372036854775807

let overflowTest = maxInt + 1 :: Int
overflowTest
-- -9223372036854775808 (d√©bordement !)

-- Avec Integer, pas de d√©bordement
let bigInteger = 9223372036854775807 :: Integer
let noProblem = bigInteger + 1 :: Integer  
noProblem
-- 9223372036854775808

-- Calculs avec grands nombres
let factorial20Int = product [1..20] :: Int
factorial20Int
-- 2432902008176640000

let factorial20Integer = product [1..20] :: Integer
factorial20Integer  
-- 2432902008176640000

let factorial50Integer = product [1..50] :: Integer
factorial50Integer
-- 30414093201713378043612608166064768844377641568960512000000000000

-- Conversions
fromIntegral (42 :: Int) :: Integer
-- 42

fromIntegral (999999999999999999999 :: Integer) :: Int
-- -1486618624 (troncature/d√©bordement)

-- Types automatiques
:t 42
-- 42 :: Num a => a

:t (42 + 1)
-- (42 + 1) :: Num a => a
```

### üìä Sortie Attendue
```
=== COMPARAISON INT VS INTEGER ===

üî¢ Valeurs de test :
‚Ä¢ smallNumber (Int) = 4611686018427387904
‚Ä¢ bigNumber (Integer) = 170141183460469231731687303715884105728
‚Ä¢ Longueur bigNumber : 39 chiffres

üìè Limites approximatives d'Int (syst√®me 64 bits) :
‚Ä¢ Maximum Int ‚âà 9223372036854775807
‚Ä¢ Minimum Int ‚âà -9223372036854775808
‚Ä¢ Plage : environ 9.223 √ó 10^18

=== COMPARAISON DES CAPACIT√âS ===

üöÄ Nombre √©norme avec Integer :
‚Ä¢ 2^1000 = 10715086071862673209484250490600018105614... (302 chiffres au total)
  ‚Üí Impossible √† repr√©senter avec Int !

=== TESTS DE FACTORIELLES ===

üî¢ Factorielles avec Int (attention aux d√©bordements) :
‚Ä¢ 1! = 1 (Int)
‚Ä¢ 5! = 120 (Int)
‚Ä¢ 10! = 3628800 (Int)
‚Ä¢ 15! = 1307674368000 (Int)
‚Ä¢ 20! = 2432902008176640000 (Int)
  ‚ö†Ô∏è  Au-del√† de 20!, les r√©sultats peuvent d√©border

üî¢ Factorielles avec Integer (pr√©cision illimit√©e) :
‚Ä¢ 1! = 1 (Integer)
‚Ä¢ 5! = 120 (Integer)
‚Ä¢ 10! = 3628800 (Integer)
‚Ä¢ 20! = 2432902008176640000 (Integer)
‚Ä¢ 30! = 265252859812191058636308480000000... (33 chiffres)
‚Ä¢ 50! = 304140932017133780436126081660647... (65 chiffres)

=== RECOMMANDATIONS D'USAGE ===

üéØ Quand utiliser Int :
‚Ä¢ ‚úÖ Calculs simples et rapides
‚Ä¢ ‚úÖ Indices de tableaux, compteurs
‚Ä¢ ‚úÖ Valeurs garanties petites
‚Ä¢ ‚úÖ Performance critique

üéØ Quand utiliser Integer :
‚Ä¢ ‚úÖ Calculs math√©matiques complexes
‚Ä¢ ‚úÖ Factorielles, puissances √©lev√©es
‚Ä¢ ‚úÖ Cryptographie, grands nombres
‚Ä¢ ‚úÖ Precision absolue requise

‚öñÔ∏è  Compromis :
‚Ä¢ Int = Vitesse vs Limitation
‚Ä¢ Integer = Pr√©cision vs Performance

‚úÖ Choisissez le bon type selon vos besoins !
```

### üöÄ Points Importants √† Retenir
1. **Int = Taille fixe** : Limit√© √† ~9 √ó 10^18, mais tr√®s rapide
2. **Integer = Pr√©cision arbitraire** : Pas de limite, mais plus lent
3. **D√©bordement d'Int** : Peut causer des erreurs silencieuses dangereuses
4. **Conversion** : `fromIntegral` pour convertir entre les types
5. **Choix selon contexte** : Performance vs Pr√©cision selon les besoins

### üß† Explication D√©taill√©e - D√©bordement d'Int

Le d√©bordement d'Int est un pi√®ge dangereux qu'Integer √©vite compl√®tement :

```haskell
-- D√âBORDEMENT DANGEREUX AVEC INT
let maxInt = 9223372036854775807 :: Int  -- Maximum
let overflow = maxInt + 1 :: Int          -- D√©borde vers le minimum !
-- overflow = -9223372036854775808       -- R√©sultat incorrect !

-- S√âCURIT√â AVEC INTEGER
let maxInteger = 9223372036854775807 :: Integer
let safe = maxInteger + 1 :: Integer      -- Pas de probl√®me
-- safe = 9223372036854775808            -- R√©sultat correct

-- C'est pourquoi Integer est pr√©f√©rable pour :
-- - Calculs financiers pr√©cis
-- - Algorithmes cryptographiques  
-- - Factorielles et combinatoires
-- - Tout calcul o√π la pr√©cision est critique
```
